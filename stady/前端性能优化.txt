/****************
动画优化
*******************/

避免重复的rendering行为
• 使用 RAF来动画逻辑在合理的刷新时间内
• 保证渲染引擎的原子操作, 分离批量dom的读写行为
• 高端浏览器中尽量使用原生的classList操作样式的切换

合理使用 GPU加速
• 使用 GPU加速, 其实是利用了GPU层的缓存,让渲染资源可以重复利用。
• GPU加速是把双刃剑, 过多的GPU层同样会带来性能开销, 请留意Composite Layouts是否超出了16ms。
• 只在用户行为和动画需要的场景去创建GPU层，但是需要及时回收。

平滑的动画
• 需要被脚本控制的动画，合理利用 GPU缓存，减少Painting
• 使用 CSS transition 完成一次性动画
• 动画过程避免布局渲染

使用 CSS3动画需要知道这些事情
• 单独使用 translate2D 并不会独立产生GPU层，不会在GPU中进行合成。
• CSS的补间动画配合translate2D，可以在GPU中产生一次临时的层以进行运算，但是遇到“布局计算”的变化则无效。
• CSS3动画通常是不被阻塞的。你可以获得独立的线程进行绘制

写在最后
• 避免重复更新渲染树– 16ms内最多出现一次Recalculate Style 和 RenderLayout
• 使用 RequestAnimationFrame
• Dom的批量操作读/写
• 使用 classList
• 绘制优化：使用 GPU加速
– 位置变化的 Render Layout 计算可以在GPU里完成
– GPU使用也需要注意缓存回收
– 一次性动画使用 CSS transition 完成
• 如果需要完全避免渲染树的计算，可以考虑Canvas


/********************
请求及页面优化
*******************/
收益大的方向
✤ 首屏最小化（尽可能控制DOM节点数、请求数、外链数）
✤ 尽可能减小页面整体内容大小
✤ 尽可能提前DOM Content Ready事件触发的时间
✤ 尽可能提前Load事件触发的时间
✤ 尽可能减少Load事件之后还要加载的资源

收益小的方向
✤ 协议自适应（减小HTML大小）
✤ 优化HTML书写顺序（减小GZip大小）
✤ DNS Prefetch

要权衡的地方
✤ 让页面渲染尽快提前
	✤ <head>中尽可能少加载资源
	✤ 资源尽可能在同一个域，减少DNS Lookup
✤ 让首屏的可视区域尽快显示
	✤ 为了提高视觉快感，可能需要提前加载部分资源
✤ 所有针对广告和直接涉及到金额部分的优化
	✤ 业务数据不能降，做好应急回滚方案（版本号、时间戳更新）
✤ 本地存储
	✤ 你得准备好内容更新机制和浏览器兼容方案

这样做就对了！
✤ 从视觉感受和数据同时分析问题，设定
优化目标
✤ 准备稳定可靠的长效数据监控机制
✤ 规划页面下载大小，尽量让首屏可视内
容等于Onload内容
✤ 根据业务优先级决定模块加载时机
✤ 重点优化默认不可见区域的内容加载
✤ 移除所有用不到的资源
✤ 与数据敏感的业务方提前接触，从设计
优化方案到优化上线全程邀请他们一起
参与，准备好应急方案